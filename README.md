# Elements of Programming Interviews

Valiantly trying to solve every single question in
[Elements of Programming Interviews](https://www.amazon.com/Elements-Programming-Interviews-Insiders-Guide/dp/1479274836)

* Completed: 106
* Remaining: 73

## Chapter 5: Primitives

- [x] 5.1: Computing the parity of a word
- [x] 5.2: Swap bits
- [x] 5.3: Reverse bits
- [x] 5.4: Find a closest integer with the same weight
- [x] 5.5: Compute `X x Y` without arithmetical operators
- [x] 5.6: Compute `X / Y`
- [x] 5.7: Compute `X ^ Y`
- [x] 5.8: Reverse digits
- [x] 5.9: Check if a decimal integer is a palindrome
- [x] 5.10: generate uniform random numbers
- [x] 5.11: Rectangle intersection

## Chapter 6: Arrays

- [x] 6.1: The Dutch national flag problem
- [x] 6.2: Increment an arbitrary-precision integer
- [x] 6.3: Multiply two arbitrary-precision integers
- [x] 6.4: Advancing through an array
- [x] 6.5: Delete a key from an array
- [x] 6.6: Delete duplicates from a sorted array
- [x] 6.7: Buy and sell a stock once
- [x] 6.8: Buy and sell a stock twice
- [x] 6.9: Enumerate all primes to n
- [x] 6.10: Permute the elements of an array
- [x] 6.11: Compute the next permutation
- [x] 6.12: Sample offline data
- [x] 6.13: Sample online data
- [x] 6.14: Compute a random permutation
- [x] 6.15: Compute a random subset
- [x] 6.16: Generate nonuniform random numbers
- [x] 6.17: The Sudoku checker problem
- [x] 6.18: Compute the spiral ordering of a 2D array
- [x] 6.19: Rotate a 2D array
- [ ] 6.20: Compute rows in Pascal's Triangle

## Chapter 7: Strings

- [x] 7.1: Interconvert strings and integers
- [x] 7.2: Base conversion
- [x] 7.3: Compute the spreadsheet column encoding
- [x] 7.4: Replace and remove
- [x] 7.5: Test palindromicity
- [x] 7.6: Reverse all the words in a sentence
- [x] 7.7: Compute all mnemonics for a phone number
- [x] 7.8: The look-and-say problem
- [x] 7.9: Convert from Roman to decimal
- [x] 7.10: Compute all valid IP addresses
- [x] 7.11: Write a string sinusoidally
- [x] 7.12: Implement run-length encoding
- [x] 7.13: Implement the UNIX `tail` command
- [ ] 7.14: Find the first occurrence of a substring

## Chapter 8: Linked Lists

- [x] 8.1: Merge two sorted lists
- [x] 8.2: Reverse a singly linked list
- [x] 8.3: Reverse a single sublist
- [x] 8.4: Test for cyclicity
- [x] 8.5: Test for overlapping lists -- lists are cycle-free
- [x] 8.6: Test for overlapping lists -- lists may have cycles
- [x] 8.7: Delete a node from a singly linked list
- [x] 8.8: Remove the `k`th last element from a list
- [x] 8.9: Remove duplicates from a sorted list
- [x] 8.10: Implement cyclic right shift for singly linked lists
- [x] 8.11: Implement even-odd merge
- [x] 8.12: Test whether a singly linked list is palindromic
- [ ] 8.13: Implement list pivoting
- [ ] 8.14: Add list-based integers

## Chapter 9: Stacks and Queues

- [x] 9.1: Implement a stack with a max API
- [x] 9.2: Evaluate RPN expressions
- [x] 9.3: Test a string of parens for well-formedness
- [x] 9.4: Normalize pathnames
- [ ] 9.5: BST keys in sort order
- [ ] 9.6: Search a postings list
- [ ] 9.7: Compute buildings with a sunset view
- [ ] 9.8: Sort a stack
- [x] 9.9: Compute binary tree nods in order of increasing depth
- [x] 9.10: Implement a circular queue
- [x] 9.11: Implement a queue using stacks
- [ ] 9.12: Implement a queue with max API

## Chapter 10: Binary Trees

- [x] 10.1: Test if a binary tree is balanced
- [x] 10.2: Test if a binary tree is symmetric
- [x] 10.3: Compute the lowest common ancestor in a binary tree
- [x] 10.4: Compute the LCA when nodes have parent pointers
- [x] 10.5: Sum the root-to-leaf paths in a binary tree
- [x] 10.6: Find a root to leaf path with specified sum
- [x] 10.7: Compute the `k`th node in an inorder traversal
- [ ] 10.8: Compute the successor
- [x] 10.9: Implement an inorder traversal with `O(1)` space
- [x] 10.10: Reconstruct a binary tree from traversal data
- [x] 10.11: Reconstruct a binary tree from a preorder traversal with markers
- [ ] 10.12: Form a linked list from the leaves of a binary tree
- [ ] 10.13: Compute the exterior of a binary tree
- [ ] 10.14: Compute the right sibling tree
- [ ] 10.15: Implement locking in a binary tree

## Chapter 11: Heaps

- [x] 11.1: Merge sorted files
- [ ] 11.2: Sort an increasing-decreasing array
- [x] 11.3: Sort an almost-sorted array
- [x] 11.4: Compute the `k` closest stars
- [x] 11.5: Compute the median of online data
- [ ] 11.6: Compute the `k` largest elements in a max-heap
- [ ] 11.7: Implement a stack API using a heap

## Chapter 12: Searching

- [x] 12.1: Search a sorted array for the first occurrence of `k`
- [x] 12.2: Search a sorted array for the first element greater than `k`
- [x] 12.3: Search a sorted array for entry equal to its index
- [x] 12.4: Search a cyclically sorted array
- [x] 12.5: Compute the integer square root
- [ ] 12.6: Compute the real square root
- [x] 12.7: Search in a 2D sorted array
- [x] 12.8: Find the min and max simultaneously
- [ ] 12.9: Find the `k`th largest element
- [ ] 12.10: Compute the optimum mailbox placement
- [ ] 12.11: Find the missing IP address
- [ ] 12.12: Find the duplicate and missing elements

## Chapter 13: Hash Tables

- [x] 13.1: Partition into anagrams
- [x] 13.2: Test for palindromic permutations
- [ ] 13.3: Is an anonymous letter constructable?
- [x] 13.4: Implement an ISBN cache
- [ ] 13.5: Compute the LCA, optimizing for close ancestors
- [ ] 13.6: Compute the `k` most frequent queries
- [x] 13.7: Find the nearest repeated entries in an array
- [ ] 13.8: Find the smallest subarray sequentially covering all values
- [ ] 13.9: Find smallest subarray sequentially covering all values
- [x] 13.10: Find the longest subarray with distinct entries
- [ ] 13.11: Find the length of a longest contained interval
- [ ] 13.12: Compute the average of the top three scores
- [ ] 13.13: Compute all string decompositions
- [ ] 13.14: Find a highest affinity pair
- [ ] 13.15: Test the Collatz conjecture
- [ ] 13.16: Implement a hash function for chess

## Chapter 14: Sorting

- [x] 14.1: Compute the intersection of two arrays
- [x] 14.2: Implement mergesort in-place
- [x] 14.3: Count the frequencies of characters in a sentence
- [x] 14.4: Remove first-name duplicates
- [x] 14.5: Render a calendar
- [ ] 14.6: Merging intervals
- [ ] 14.7: Compute the union of intervals
- [ ] 14.8: Partitioning and sorting an array with many repeated entries
- [ ] 14.9: Team photo day-1
- [ ] 14.10: Implement a fast sorting algorithm for lists
- [ ] 14.11: Compute a salary threshold

## Chapter 15: Binary Search Trees

- [x] 15.1: Test if a binary tree satisfies the BST property
- [x] 15.2: Find the first occurrence of a key in a BST
- [x] 15.3: Find the first key larger than a given value in a BST
- [x] 15.4: Find the `k` largest elements in a ST
- [x] 15.5: Compute the LCA in a BST
- [ ] 15.6: Reconstruct a BST from traversal data
- [ ] 15.7: Find the closest entries in three sorted arrays
- [ ] 15.8: Enumerate numbers of the form `a + b sqrt(2)`
- [ ] 15.9: The most visited pages problem
- [ ] 15.10: Build a minimum-height BST from a sorted array
- [ ] 15.11: Insertion and deletion in a BST
- [ ] 15.12: Test if three BST nodes are totally ordered
- [ ] 15.13: The range lookup problem
- [ ] 15.14: Add credits
- [ ] 15.15: Count the number of entries in an interval

## Chapter 16: Recursion

- [ ] 16.1: The Tower of Hanoi problem
- [ ] 16.2: Generate all nonattacking placements of `n`-Queens
- [ ] 16.3: Generate permutations
- [x] 16.4: Generate the power set
- [ ] 16.5: Generate all subsets of `k`
- [ ] 16.6: Generate strings of matched parens
- [ ] 16.7: Generate palindromic decompositions
- [ ] 16.8: Generate binary trees
- [ ] 16.9: Implement a Sudoku solver
- [ ] 16.10: Compute a Gray code
- [ ] 16.11: Compute the diameter of a tree

## Chapter 17: Dynamic Programming

- [x] 17.1: Count the number of score combinations
- [x] 17.2: Compute the Levenshtein distance
- [x] 17.3: Count the number of ways to traverse a 2D array
- [ ] 17.4: Compute the binomial coefficients
- [ ] 17.5: Search for a sequence in a 2D array
- [x] 17.6: The knapsack problem
- [x] 17.7: The `bedbathandbeyond` problem
- [ ] 17.8: Find the minimum weight path in a triangle
- [ ] 17.9: Pick up coins for maximum gain
- [x] 17.10: Count the number of moves to climb stairs
- [ ] 17.11: The pretty printing problem
- [ ] 17.12: Find the longest nondecreasing subsequence

## Chapter 18: Greedy Algorithms and Invariants

- [ ] 18.1: Implement Huffman coding
- [ ] 18.2: Compute an optimum assignment of tasks
- [ ] 18.3: Schedule to minimize waiting time
- [ ] 18.4: The interval covering problem
- [x] 18.5: The 3-Sum problem
- [x] 18.6: Find the majority element
- [x] 18.7: The gasup problem
- [x] 18.8: Compute the maximum water trapped by a pair of vertical lines
- [ ] 18.9: Compute the largest rectangle under the skyline
