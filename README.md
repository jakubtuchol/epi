# Elements of Programming Interviews

Valiantly trying to solve every single question in
[Elements of Programming Interviews](https://www.amazon.com/Elements-Programming-Interviews-Insiders-Guide/dp/1479274836)

## Chapter 5: Primitives

- [x] 5.1: Computing the parity of a word
- [ ] 5.2: Swap bits
- [x] 5.3: Reverse bits
- [ ] 5.4: Find a closest integer with the same weight
- [ ] 5.5: Compute `X x Y` without arithmetical operators
- [ ] 5.6: Compute `X / Y`
- [ ] 5.7: Compute `X ^ Y`
- [x] 5.8: Reverse digits
- [x] 5.9: Check if a decimal integer is a palindrome
- [ ] 5.10: generate uniform random numbers
- [x] 5.11: Rectangle intersection

## Chapter 6: Arrays

- [x] 6.1: The Dutch national flag problem
- [x] 6.2: Increment an arbitrary-precision integer
- [x] 6.3: Multiply two arbitrary-precision integers
- [ ] 6.4: Advancing through an array
- [ ] 6.5: Delete a key from an array
- [ ] 6.6: Delete duplicates from a sorted array
- [x] 6.7: Buy and sell a stock once
- [ ] 6.8: Buy and sell a stock twice
- [ ] 6.9: Enumerate all primes to n
- [x] 6.10: Permute the elements of an array
- [ ] 6.11: Compute the next permutation
- [x] 6.12: Sample offline data
- [ ] 6.13: Sample online data
- [ ] 6.14: Compute a random permutation
- [ ] 6.15: Compute a random subset
- [x] 6.16: Generate nonuniform random numbers
- [x] 6.17: The Sudoku checker problem
- [x] 6.18: Compute the spiral ordering of a 2D array
- [ ] 6.19: Rotate a 2D array
- [ ] 6.20: Compute rows in Pascal's Triangle

## Chapter 7: Strings

- [x] 7.1: Interconvert strings and integers
- [x] 7.2: Base conversion
- [ ] 7.3: Compute the spreadsheet column encoding
- [ ] 7.4: Replace and remove
- [x] 7.5: Test palindromicity
- [x] 7.6: Reverse all the words in a sentence
- [x] 7.7: Compute all mnemonics for a phone number
- [x] 7.8: The look-and-say problem
- [x] 7.9: Convert from Roman to decimal
- [ ] 7.10: Compute all valid IP addresses
- [ ] 7.11: Write a string sinusoidally
- [ ] 7.12: Implement run-length encoding
- [x] 7.13: Implement the UNIX `tail` command
- [ ] 7.14: Find the first occurrence of a substring

## Chapter 8: Linked Lists

- [x] 8.1: Merge two sorted lists
- [x] 8.2: Reverse a singly linked list
- [ ] 8.3: Reverse a single sublist
- [x] 8.4: Test for cyclicity
- [x] 8.5: Test for overlapping lists -- lists are cycle-free
- [x] 8.6: Test for overlapping lists -- lists may have cycles
- [ ] 8.7: Delete a node from a singly linked list
- [x] 8.8: Remove the `k`th last element from a list
- [ ] 8.9: Remove duplicates from a sorted list
- [ ] 8.10: Implement cyclic right shift for singly linked lists
- [x] 8.11: Implement even-odd merge
- [x] 8.12: Test whether a singly linked list is palindromic
- [ ] 8.13: Implement list pivoting
- [ ] 8.14: Add list-based integers

## Chapter 9: Stacks and Queues

- [x] 9.1: Implement a stack with a max API
- [x] 9.2: Evaluate RPN expressions
- [x] 9.3: Test a string of parens for well-formedness
- [x] 9.4: Normalize pathnames
- [ ] 9.5: BST keys in sort order
- [ ] 9.6: Search a postings list
- [ ] 9.7: Compute buildings with a sunset view
- [ ] 9.8: Sort a stack
- [x] 9.9: Compute binary tree nods in order of increasing depth
- [x] 9.10: Implement a circular queue
- [x] 9.11: Implement a queue using stacks
- [ ] 9.12: Implement a queue with max API

## Chapter 10: Binary Trees

- [x] 10.1: Test if a binary tree is balanced
- [x] 10.2: Test if a binary tree is symmetric
- [ ] 10.3: Compute the lowest common ancestor in a binary tree
- [x] 10.4: Compute the LCA when nodes have parent pointers
- [ ] 10.5: Sum the root-to-leaf paths in a binary tree
- [ ] 10.6: Find a root to leaf path with specified sum
- [ ] 10.7: Compute the `k`th node in an inorder traversal
- [ ] 10.8: Compute the successor
- [ ] 10.9: Implement an inorder traversal with `O(1)` space
- [x] 10.10: Reconstruct a binary tree from traversal data
- [ ] 10.11: reconstruct a binary tree from a preorder traversal with markers
- [ ] 10.12: Form a linked list from the leaves of a binary tree
- [ ] 10.13: Compute the exterior of a binary tree
- [ ] 10.14: Compute the right sibling tree
- [ ] 10.15: Implement locking in a binary tree
